name,ring,quadrant,status,description
.tool-versions files,Adopt,Tools,no change,
Colima,Adopt,Tools,no change,"<p><strong><a href=""https://github.com/abiosoft/colima"">Colima</a></strong> is now our go-to alternative to Docker Desktop on macOS. We continue to use it on several projects to provision the Docker container run time in a <a href=""https://github.com/lima-vm/lima"">Lima VM</a>, to configure the Docker CLI on macOS and to handle port-forwarding and volume mounts. Colima can be configured to run <a href=""https://containerd.io/"">containerd</a> as its run time, which is also the run time on most managed <a href=""/radar/platforms/kubernetes"">Kubernetes</a> services, improving the important dev-prod parity.</p>"
dbt,Adopt,Tools,no change,"<p><a href=""https://www.getdbt.com/""><strong>dbt</strong></a> continues to be our tool of choice for data transformations in the ELT workflow. We like that it lends itself to engineering rigor and enables practices like modularity, testability and reusability of SQL-based transformations. dbt is available both as an open-source and commercial SaaS product and has a healthy ecosystem, including a community hub with packages for unit testing, data quality and data observability, to name a few. Packages worth highlighting include <a href=""/radar/languages-and-frameworks/dbt-expectations"">dbt-expectations</a> and <a href=""/radar/languages-and-frameworks/dbt-unit-testing"">dbt-unit-testing</a> which facilitate data quality checks and unit testing of the transformations, respectively. dbt <a href=""https://docs.getdbt.com/docs/supported-data-platforms"">integrates</a> well with a variety of cloud data warehouses, lakehouses and databases, including <a href=""/radar/platforms/snowflake"">Snowflake</a>, <a href=""/radar/platforms/bigquery"">BigQuery</a>, Redshift, Databricks and Postgres. When working with structured data where one can set up transformations as SQL, our teams prefer dbt — which is why we're moving it to Adopt.</p>"
OrbStack,Adopt,Tools,no change,"<p><strong><a href=""https://orbstack.dev/"">OrbStack</a></strong> is a way to run Docker containers on macOS; our developers have found it to be more lightweight, faster and simpler to set up and use than <a href=""https://www.docker.com/products/docker-desktop/"">Docker Desktop</a> and <a href=""/radar/platforms/colima"">Colima</a>. The tool is still under development and therefore has fewer features, but it's already showing some great potential with its simplicity and speed. You can also use OrbStack to create and manage Linux VMs on macOS.</p>"
Launchpad,Assess,Tools,no change,<p>A Clojure dev process launcher from Lambda Island.</p>
GitHub merge queue,Assess,Tools,no change,"<p>Merge queues allow teams to automatically queue up incoming pull requests and merge them into a special branch in the order they were received. This essentially simulates trunk-based development (even though PRs have not been merged into the main code branch yet) and allows developers to test their features in context without having to wait for the pull request to be approved. With GitHub merge queue,  you get the benefits of trunk-based development even when you're not able to commit to working on small, short lived, branches, being merged quickly and often.</p><p>Merge queues <em>could</em> be particularly useful in an environment where <em>stacked</em> PRs are a practice the team engages in.</p>"
Mocks Server,Assess,Tools,no change,"<p><strong><a href=""https://www.mocks-server.org/"">Mocks Server</a></strong> is a Node.js-based API mocking tool valued by our teams for its ability to replicate intricate API responses, headers and status codes. The dynamic response generation supports the simulation of diverse scenarios, which allows for the rigorous testing of API interactions. Mocks can be described as YAML or JSON and managed through the CLI, REST API or JavaScript code. Mocks Server's features include request matching, proxying and record-playback features, which facilitate the emulation of realistic API interactions. We particularly like the integration with Docker containers, which makes it easy to deploy the server consistently between environments so it can be versioned and maintained as another artifact of the ecosystem. Its straightforward approach aligns with our emphasis on simplicity and efficiency in development processes. We look forward to using Mocks Server more extensively as our testing strategy evolves along with our solutions.</p>"
Devbox,Trial,Tools,no change,"<p><strong><a href=""https://www.jetpack.io/devbox/"">Devbox</a></strong> is a terminal-based tool that provides an approachable interface for creating reproducible, per-project development environments, leveraging the Nix package manager without using virtual machines or containers. Our teams use it to eliminate version and configuration mismatches of CLI tools and custom scripts in their per-project development environments, on top of the standardization that per-language package managers provide. They found that it notably streamlines their onboarding workflow because once it has been configured for a codebase, it takes one CLI command (<code>devbox shell</code>) to stand it up in a TRUE machine. Devbox supports shell hooks, custom scripts and <a href=""https://containers.dev/"">devcontainer.json</a> generation for integration with VSCode.</p>"
Mermaid,Trial,Tools,no change,"<p><a href=""https://mermaid.js.org/""><strong>Mermaid</strong></a> lets you generate diagrams from a Markdown-like markup language. Since we last featured it in the Radar, Mermaid has added support for many more diagrams and <a href=""https://mermaid.js.org/ecosystem/integrations.html"">integrations</a> with source code repositories, IDEs and knowledge management tools. Notably, it's supported natively in popular source code repositories such as GitHub and GitLab, enabling the embedding of and easy updates to Mermaid diagrams in the middle of Markdown documentation. Many of our teams gravitate toward Mermaid as their diagram-as-code tool due to its ease of use, multitude of integrations and wide variety of supported diagram types that keep growing.</p>"
Continuous Delivery,Adopt,Techniques,no change,"<p>Continuous delivery focuses on maximizing automation including infrastructure as code, environment management and deployment automation to ensure your system is always ready for production.</p><p>It is about tightening your feedback loops and not putting off anything until the end. Continuous delivery is not the same as continuous deployment, which means deploying every change to production. The business can still pick and choose what and when to deploy.</p>"
Automatic merging of dependency update PRs,Assess,Techniques,no change,"<p>The complexity of the software supply chain is a major risk, and we've covered it extensively, for example, in our write-ups on <a href=""/radar/techniques/software-bill-of-materials"">SBOM</a> and <a href=""/radar/techniques/slsa"">SLSA</a>. The Achilles heel for most teams is still the presence of vulnerabilities in dependencies, often indirect dependencies several levels down. Tools such as <a href=""/radar/tools/dependabot"">Dependabot</a> help by creating pull requests (PRs) to update dependencies. It requires engineering discipline, though, to look after these PRs promptly, especially when they are for applications or services that are not under active development.</p><p>Under the right circumstances we now advocate for <strong>automatic merging of dependency update PRs</strong>. This requires that the system has extensive test coverage — not only unit tests but also functional and performance tests. The build pipeline must run all of these tests, and it must include security scanning. In short, the team must have full confidence that when the pipeline runs successfully the software is ready to go into production. In such cases, dependency update PRs, even when they include major version updates in indirect dependencies, should be merged automatically.</p>"
Unit testing for alerting rules,Assess,Techniques,no change,"<p>Observability and monitoring are essential for software teams. Given the unpredictable nature of certain events, creating accurate alert mechanisms with complex rules is crucial. However, the true validation of these rules comes only when scenarios arise in the wild. The <strong>unit testing for alerting rules</strong> technique allows teams to better define rules by proactively testing and refining them beforehand, increasing confidence in the way the rule is set up. This helps to reduce false alarms and ensure genuine issues are highlighted. Tools like <a href=""/radar/tools/prometheus"">Prometheus</a> support <a href=""https://prometheus.io/docs/prometheus/latest/configuration/unit_testing_rules/"">unit testing for rules</a>; our teams are already reporting its benefits in real-world settings.</p>"
Zero trust security for CI/CD,Assess,Techniques,no change,"<p>If not properly secured, the infrastructure and tools that run our build and delivery pipelines can become a big liability. Pipelines need access to critical data and systems like source code, credentials and secrets to build and deploy software. This makes these systems very inviting to malicious actors. We therefore highly recommend applying <strong><a href=""/radar/techniques/zero-trust-architecture"">zero trust</a> security for CI/CD</strong> pipelines and infrastructure — trusting them as little as necessary. This encompasses a number of techniques: If available, authenticate your pipelines with your cloud provider via federated identity mechanisms like <a href=""/radar/techniques/oidc-for-github-actions"">OIDC</a>, instead of giving them direct access to secrets; implement the principle of least privilege by minimizing the access of individual user or runner accounts, rather than employing ""god user accounts"" with unlimited access; use your runners in an ephemeral way instead of reusing them, to reduce the risk of exposing secrets from previous jobs or running jobs on compromised runners; keep the software in your agents and runners up to date; and monitor the integrity, confidentiality and availability of your CI/CD systems the same way you would monitor your production software.</p><p>We're seeing teams forget about these types of practices, particularly when they’re used to working with a self-managed CI/CD infrastructure in internal network zones. While all of these practices are important in your internal networks, they become even more crucial when using a managed service, as that extends the attack surface and blast radius even more.</p>"
Ignoring OWASP Top 10 lists,Hold,Techniques,no change,"<p>The <a href=""https://owasp.org/www-project-top-ten/"">OWASP Top 10</a> has long been a go-to reference for the most critical security risks to web applications. Despite being well-known, we've previously written about it being underused in the software development process and cautioned against <a href=""/radar/techniques/ignoring-owasp-top-10"">ignoring OWASP Top 10</a>.</p><p>What is less well-known is that OWASP also publishes similar top 10 lists for other categories. The <a href=""https://owasp.org/www-project-top-10-for-large-language-model-applications/"">OWASP Top 10 list for LLMs</a>, whose first major version was released early August, highlights risks such as prompt injection, insecure output handling, training data poisoning and others that individuals and teams building LLM applications would do well to be aware of. OWASP has also recently released the second version of its <a href=""https://owasp.org/API-Security/editions/2023/en/0x00-header/"">OWASP Top 10 list for APIs</a>. Given the OWASP Top 10 lists' breadth of coverage (web applications, APIs, LLMs and <a href=""https://owasp.org/www-project-serverless-top-10/"">more</a>), quality and relevance to the continuously changing security landscape, we extend our previous recommendation to caution teams against <strong>ignoring OWASP Top 10 lists</strong>.</p>"
Decoupling Deployment from Release,Trial,Techniques,no change,"<p><em>Deployment</em> refers to the act of deploying a change to application components or infrastructure. Whereas <em>Release</em> should be used to refer to when a feature change is released to end users, with a business impact.</p><p>Using techniques such as feature toggles and dark launches, we should be able to deploy changes to production systems more frequently without releasing features. More-frequent deployments reduce the risk associated with change, while stakeholders retain control over when features are released to end users.</p>"
Lightweight Architecture Decision Records,Trial,Techniques,no change,"<p>Much documentation can be replaced with highly readable code and tests. In a world of evolutionary architecture, however, it's important to record certain design decisions for the benefit of future team members as well as for external oversight.</p><p>Lightweight Architecture Decision Records is a technique for capturing important architectural decisions along with their context and consequences.</p><p>These details should be stored in source control, instead of a wiki or website, as then they can provide a record that remains in sync with the code itself.</p>"
Continuous Deployment,Trial,Tecehniques,no change,"<p>Building on from a successful practice of <em>Continuous Delivery</em> we should explore an evolution towards Continuous <em>Deployment</em> where changes are automatically deployed to production without human intervention.</p><p>This should be paired with other practices such as <em>Decoupling deployment from release</em>.</p>"
AWS Fargate,Adopt,Platforms,no change,"<p>AWS Fargate is the the docker-as-a-service option on AWS, is now widely available across regions. It's a great solution for situations in which teams, like ours, want to run Docker containers without having to manage EC2 instances.</p><p>It’s a particularly attractive option for migrating away from Elastic Beanstalk and promises better performance and faster deployments.</p>"
Buildkite,Assess,Platforms,no change,"<p>Buildkite is a self hosted CI/CD tool with an emphasis on simplicity and quick setup.</p><p>We’ve found the flexibility of running on our own (cloud) hardware and the level of control over the configuration of the build agents to be a significant improvement over Travis CI. The greater control offered by Buildkite allows us to more freely adapt it to our needs both as a build system and general job executor.</p>"
GitHub Actions,Assess,Platforms,no change,"<p>GitHub Actions is a fully featured CI/CD platform with broad community support.</p>"
CloudEvents,Assess,Platforms,no change,"<p>Events are common mechanisms in event-driven architecture or <a href=""/radar/techniques/serverless-architecture"">serverless</a> applications. However, producers or cloud providers tend to support them in different forms, which prevents interoperability across platforms and infrastructures. <strong><a href=""https://cloudevents.io/"">CloudEvents</a></strong> is a specification for describing event data in common formats to provide interoperability across services, platforms and systems. It provides SDKs in multiple languages so you can embed the spec into your application or toolchain. Our teams use it not only for cross-cloud platform purposes but also for domain event specification, among other scenarios. CloudEvents is hosted by the <a href=""https://www.cncf.io/"">Cloud Native Computing Foundation</a> (CNCF) and now runs as an incubator project that has been gaining increasing industry attention.</p>"
pgvector,Assess,Platforms,no change,"<p>With the rise of Generative AI-powered applications, we see a pattern of storing and efficiently searching <a href=""https://www.featureform.com/post/the-definitive-guide-to-embeddings"">embeddings</a> vectors for similarities. <strong><a href=""https://github.com/pgvector/pgvector"">pgvector</a></strong> is an open-source vector similarity search extension for PostgreSQL. We quite like it because it enables us to search the embeddings in PostgreSQL without moving the data to another store just for similarity search. Although there are several specialized <a href=""https://github.com/currentslab/awesome-vector-search"">vector search engines</a>, we want you to assess pgvector.</p>"
Elastic Beanstalk,Hold,Platforms,no change,
Renovate,Trial,Platforms,no change,<p>Renovate is a tool for keeping dependencies up to date which supports a wide range of hosting services and programming languages.</p>
aero,Adopt,languages-and-frameworks,no change,
Cognitect AWS,Adopt,languages-and-frameworks,no change,
integrant,Adopt,languages-and-frameworks,no change,
kaocha,Adopt,languages-and-frameworks,no change,
malli,Adopt,languages-and-frameworks,no change,
Playwright,Trial,languages-and-frameworks,no change,"<p>With <strong><a href=""https://playwright.dev/"">Playwright</a></strong> you can write end-to-end tests that run in Chrome, Firefox and WebKit. By using the Chrome DevTools Protocol (CDP) Playwright can offer TRUE features and eliminate many of the issues seen with WebDriver. Chromium-based browsers implement CDP directly. To support Firefox and Webkit, though, the Playwright team has to submit patches to these browsers, which may sometimes limit the framework.</p><p>Playwright’s many features include: Built-in auto-waits, which result in tests that are more reliable and easier to understand; browser contexts, which let you test that persisting sessions across tabs work properly; and the ability to simulate notifications, geolocation and dark mode settings. Our teams are impressed with the stability Playwright brings to the test suite and like that they get feedback more quickly by running tests in parallel. Other features that set Playwright apart include better support for lazy loading and tracing. Although Playwright has some limitations — component support is currently experimental, for example — our teams consider it the go-to test framework and in some cases are migrating away from <a href=""/radar/tools/cypress"">Cypress</a> and <a href=""/radar/languages-and-frameworks/puppeteer"">Puppeteer</a>.</p>"
re-frame,Adopt,languages-and-frameworks,no change,
reitit,Adopt,languages-and-frameworks,no change,
Pedestal,Assess,languages-and-frameworks,no change,
Amazonica,Hold,languages-and-frameworks,no change,
Bedrock,Hold,languages-and-frameworks,no change,
Yada,Hold,languages-and-frameworks,no change,
OpenTelemetry,Trial,languages-and-frameworks,no change,"<p>We've been using <strong><a href=""https://opentelemetry.io/"">OpenTelemetry</a></strong> as a solution for a while now and recommended trying it in previous editions. Its ability to seamlessly capture, instrument and manage telemetry data across various services and applications has improved our observability stack. OpenTelemetry's flexibility and compatibility with diverse environments have made it a valuable addition to our toolkit. We're now particularly curious about the recent release of the <a href=""https://opentelemetry.io/docs/specs/otel/protocol/"">OpenTelemetry Protocol (OTLP)</a> specification, which includes both gRPC and HTTP. This protocol standardizes the format and transmission of telemetry data, promoting interoperability and simplifying integrations with other monitoring and analysis tools. As we continue to explore the integration potential of the protocol, we're evaluating its long-term impact on our monitoring and observability strategy and on the general monitoring landscape.</p>"
Portfolio,Trial,languages-and-frameworks,no change,"<p><a href=""https://github.com/cjohansen/portfolio"">Portfolio</a> is a “visual REPL” that aims to bring the best features of <a href=""https://github.com/storybookjs/storybook"">Storybook.js</a> to ClojureScript frontend application development.</p>"
Telemere,Trial,languages-and-frameworks,moved in,"<p><a href=""https://www.taoensso.com/telemere"">Telemere</a> is Peter Taoussanis replacement for Timbre and represents a refinement of the ideas he’s developed over the 12+ years of working on that library and others.</p><p>Telemere handles structured and traditional logging, tracing, and basic performance monitoring with a simple unified API.</p>"
